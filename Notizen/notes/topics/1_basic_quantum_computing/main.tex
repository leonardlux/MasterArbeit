\section{Basic Quantum Computing}

\subsection{Physical and Logical Qubit}

We increase the number of qubits used for our encoding to \textit{redundantly} store the information in the expaneded Hilbert space.

The specific set of instruction on how the information of a single physical 
qubit is encoded onto mulitple qubits is called:
Quantum Error Correction Code (QEC code) or simply encoding.

The \textit{distance} $d$ is a property of this code which describes, 
the minimal number of errors that will change one 
codeword\footnote{A codeword is the set of physical qubits that describe the logical qubit} to another.
In other words, the minimal amount of errors need for an error to go undeteced.

A logical qubit is noted by a subscript $L$: $\ket{\Psi}_L$

The distance is realted to the number of errors $t$ a code can correct
\begin{equation}
    d = 2t+1.
\end{equation}

\subsubsection{[[n,k,d]]-Notation}
\begin{itemize}
    \item n: total number of physical qubits per codeword
    \item k: number of encoded qubits (length of the logical qubit)
    \item d: code distance
\end{itemize}
 
\subsection{Computational Space/Basis}

'Qubits can encode information in a superposition of their basis state $\rightarrow$ computational space scales as $2^n$.'

\textcolor{red}{What exactly is the Computational space? what are its properties and what is the physical meaning of a \textit{computational} basis. 
Is it just the fact that our quantum computer is acting on this space?}


\textcolor{red}{What exactly is the difference to classical computing, the data stored also scales with $2^n$, where $n$ is the amount of bits.
How can we say it as simple as said there?
}


\subsection{Digitasition of quantum errors}

Due to bits beeing discrete in the classical case there is only one type of errors (bit-flips). 
But the qubit can exist everywhere on the Bloch sphere, so in a conitinum. 
Erros can therefore take also an infinte amout of forms.
We focus on coherent (=unitary) rotations as an example
\begin{equation}
    U(\delta \theta, \delta \phi) \ket{\Psi}=
    \cos\left(\frac{\theta + \delta \theta}{2}\right) \ket{0} +
    e^{i(\phi + \delta \phi)} 
    \sin\left(\frac{\theta + \delta \theta}{2}\right) \ket{1}.
\end{equation} 

Quantum errors can be digitazied using the Pauli matricies/operator. 
To show this we express the rot. op. $U$ using the Pauli set/\textcolor{red}{basis?} 
%$\{\mathds{1},{X},{Z},{XZ}\}$
\footnote{We used that $XZ=Yc$, where $c$ is just a phase factor.}

\begin{equation}
    U(\delta \theta, \delta \phi)\ket{\Psi} = 
    \alpha_1 \mathds{1} \ket{\Psi} +
    \alpha_X X \ket{\Psi}+
    \alpha_Z Z \ket{\Psi}+
    \alpha_{XZ} XZ \ket{\Psi}
\end{equation}

Therefore any coherent rot.\footnote{This could also be generalized for arb. quantum processes} can be decomposed into a sum from the Pauli set. 

Resulting from this QEC codes with the ability to correct errors described by the $X$- and $Z$-Pauli matricies will be able to correct any (coherent) error!

This is the digitasition of errors for quantum computing.
\subsection{Quantum error types}
 there are only two fundamental error types, that need to be accounted for.

\begin{enumerate}
    \item Pauli $X$-type errors $=$ quantum bit-flips \\
    $\rightarrow$ maps: $X\ket{0} = \ket{1}; X \ket{\Psi}= \alpha X \ket{0} + \beta X \ket{1} = \alpha  \ket{1} + \beta \ket{0}   $
    \item Pauli $Z$-type errors $=$ phase-flips (no classical analogone)\\
    $\rightarrow$ maps:  $Z \ket{\Psi}= \alpha Z \ket{0} + \beta Z \ket{1} = \alpha  \ket{0} - \beta \ket{1}   $
\end{enumerate}


\subsection{Challenges of QEC}
\subsubsection{1. No cloning theorem}
It is not possible to construct a unitary operator $U_{clone}$ which performs the operation
\begin{equation}
    U_{clone}(\ket{\Psi} \otimes \ket{0}) \rightarrow \ket{\Psi} \otimes\ket{\Psi}
\end{equation}

\subsubsection{2. Both bit- and phase-flips}
QEC codes must be designed to detect both kinds ($X,Z$) of errors simultaneously!

\subsubsection{3. Wavefct. collpase}
We can not perform arbitrary measurments on the qubits. 
Some measurments will lead to wavefct collapse and erase encoded information.
\textcolor{red}{Better describe when the wavefct actually collapses}

$\rightarrow$ stabilizer measurments

\subsection{Encoding (Codeapce and error subspace)}

While encoding, with an $[[n,k,d]]$ code, we increase the size of the Hilbert space by adding $m=n-k$ redundancy qubits $\ket{0}_R$
to create a logical qubit $\ket{\Psi}_L$. 
Afterwards the data previously stroed solely in $\ket{\Psi}_D$ is distributed across the expanded Hilbert space.

This Hilbert space can then be split up into two subspaces. 
The \textit{codespace} $\mathcal{C}$ is the subspace on which the logical qubit is defined.
The \textit{error subspace} $\mathcal{F}$ is the subspace, in which the logical qubit rotates to, when applying an error operator. 

The two subspaces ($\mathcal{F} , \mathcal{C}$) are mutual orthogonal. 
Therefore we can distinguish which subspace is occupid via projective measurments, 
without compromising the encoded quantum information! 

$\rightarrow$ projective measurments = stabilizer measurments

\subsubsection{Example of Encoding with Spaces}
For example if we start with one qubit, we start with 
\begin{equation}
    \ket{\Psi} \in \mathcal{H}_2 = \text{span}\{\ket{0},\ket{1} \}.
\end{equation}
After the encoding (by adding another qubit) we get a 4-dim Hilbert space 
\begin{equation}
    \ket{\Psi} \in \mathcal{H}_4 = \text{span}\{\ket{00},\ket{01},\ket{10},\ket{11} \}.
\end{equation}

This higher dimensional space can be used to redundantly encode the information.
The logical qubit is defined within a 2-dim subspace, which is called the \textit{codespace} $\mathcal{C}$

\begin{equation}
    \ket{\Psi}_L \in \mathcal{C} = \text{span}\{\ket{00},\ket{11} \} \subset \mathcal{H}_4.
\end{equation}

Applying an error (e.g. bit-flip $X$) roatates the state in the \textit{error subspace} $\mathcal{F}$
\begin{equation}
    X_i \ket{\Psi}_L \in \mathcal{F} = \text{span}\{\ket{01},\ket{10} \} \subset \mathcal{H}_4.
\end{equation} 


\subsection{Stabilizer}\label{sec:basic.qc.stabilizer}

A \textit{stabilizer} $P_i$ is a 
\hyperref[sec:basic.math.projection_operator]{projection operator} 
that maps the states to the $\pm 1$ eigenspaces.
The stabilizer of a $[[n,k,d]]$ code must satisfy
\begin{enumerate}
    \item must be a Pauli-group element. $P_i \in \mathcal{G}_n$ 
    \item must \textit{stabilize}\footnote{Leaves the logical state unchanged} all logical states $\ket{\Psi}_L$ of the code \\
    $\implies P_i \ket{\Psi}_L = (+1) \ket{\Psi}_L \forall \ket{\Psi}_L \in \mathcal{C} $ 
    \item all stabilizer must commute\footnote{
It is necessary that the stabilizer commute, so that they can be measured simultaneously/independent from each other. 
    } with one another $[P_i,P_j]=0 \ \forall (i,j)$
\end{enumerate}
Therefore the stabilizers of an $[[n,k,d]]$ code form an \textit{Abelian subgroup} $\mathcal{S}$ of the Pauli group.

\begin{equation}
    \mathcal{S} = \{ P_i \in \mathcal{G}_n | P_i \ket{\Psi}_L = (+1) \ket{\Psi}_L \forall \ket{\Psi}_L\in \mathcal{C} \land [P_i,P_j]=0 \ \forall(i,j)\}
\end{equation}
\textcolor{red}{Do we wanna use each $P_i \in \mathcal{S}$, that is contained in the set above?!? -> no! minimal set?!}

Importantly the product of two stabilizers is also a stabilizer $P_i \cdot P_j \in \mathcal{S}$, due to
\begin{equation}
    P_i \cdot P_j  \ket{\Psi}_L = P_i (+1) \ket{\Psi}_L = (+1) \ket{\Psi}_L.
\end{equation}
Therefore we need to make sure that the stabilizers form a \hyperref[sec:basic.math.minimal_set]{minimal set}. 
\begin{equation}
    \mathcal{S}= \langle G_1, G_2, ..., G_m\rangle
\end{equation}



\subsubsection{Example of Stabilizer Measurments}
Error can be deteced by performing $n-k=m$ stabilizer measurments $P_i$.
\textcolor{red}{Add the commutation condition with error operators}

An example for a stabilizer measurment for the previously shown encoding is 
\begin{equation}
    Z_1 Z_2 \ket{\Psi}_L = Z_1 Z_2 (\alpha \ket{00}+ \beta \ket{11}) = +1 \ket{\Psi}_L
\end{equation}

\begin{equation}
    Z_1 Z_2 X_1\ket{\Psi}_L = Z_1 Z_2 (\alpha \ket{10}+ \beta \ket{01}) = -1 \ket{\Psi}_L
\end{equation}

A stabilizer measurments projects the all elements of the codespace onto the $+1$ eigenspace 
and projects (some/in total all) elements of error space onto the $-1$ eigenspace. 

The information encoded in the logical qubit ($\alpha/\beta$ coef.) is undisturbed!

\subsubsection{Syndrome and Ancilla}
