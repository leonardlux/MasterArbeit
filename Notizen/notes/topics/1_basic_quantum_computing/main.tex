\section{Basic Quantum Computing}


\subsection{Physical and Logical Qubit}
We increase the number of qubits used for our encoding to \textit{redundantly} store the information in the expanded Hilbert space. \cite{QECintro}

The specific set of instruction on how the information of a single physical 
qubit is encoded onto mulitple qubits is called:
Quantum Error Correction Code (QEC code) or simply encoding. \cite{QECintro}

The \textit{distance} $d$ is a property of this code which describes, 
the minimal number of errors that will change one 
codeword\footnote{A codeword is the set of physical qubits that describe the logical qubit} to another.
In other words, the minimal amount of errors need for an error to go undeteced. \cite{QECintro}

This definition is equivalent with the definition, that the distance $d$ as the minimum weight of any logical operator. \cite{QECmemory}

A logical qubit is noted by a subscript $L$: $\ket{\Psi}_L$
\textcolor{red}{alternative notation has it with an bar ontop}


\subsection{Correctable Errors}
The distance is realted to the number of errors $t$ a code can correct \cite{QECintro}
\textcolor{red}{What exactly is this number of errors $t$, is it the max weight of an correctable error operator?}
\begin{equation}
    d = 2t+1.
\end{equation}
Errors with weight at most $t$, have the property that their products have weight at most $2t<d$.
Therefore the product of these operators can never be a logical operator, as those have weight $d$ or more. 
If error $E_1$ occurs and our decoder picks another error with the same syndrome $E_2$, 
we effectively get the state $E_2 E_1 \ket{\Psi}_L = E_{combined} \ket{\Psi}_L$, where both errors have weight $\leq t$.
This state has a trivial syndrome, because all parity checks/stabilizers commute with $E_{combined}$.
($E_2$ and $E_1$ have the same syndrome, therefore they either both anticommute or commute with the stabilizers.) 
Thus $E_{combined}$ having weight $2t<d$ cannot be logical operator but the parity checks only show trivial results. \cite{QECmemory}
Therefore the state is still in the codespace (and no logical operator could have occured).

 
\subsection{Computational Space/Basis}
'Qubits can encode information in a superposition of their basis state $\rightarrow$ computational space scales as $2^n$.' \cite{QECintro}

\textcolor{red}{What exactly is the Computational space? what are its properties and what is the physical meaning of a \textit{computational} basis. 
Is it just the fact that our quantum computer is acting on this space?}

\textcolor{red}{What exactly is the difference to classical computing, the data stored also scales with $2^n$, where $n$ is the amount of bits.
How can we say it as simple as said there?
}


\section{Basics of Quantum Error Correction (QEC)}
The goal of quantum error correction (QEC) is to preserve not a single macroscopic quantum state but the macroscopic state in a small subspace. \cite{QECmemory}

We can destinguish between active and passive QEC (or self correction).
In the latter quantum information is encoded in physical degrees of freedom which are naturally protected or have litte decoherence. \cite{QECmemory}
We will focus on the active kind.


\subsection{Digitisation of quantum errors}
Due to bits beeing discrete in the classical case there is only one type of errors (bit-flips). 
But the qubit can takes state everywhere on the Bloch sphere, so in a conitinuum. 
Errors can therefore take also an infinte amount of forms.
We focus on coherent (=unitary) rotations as an example
\begin{equation}
    U(\delta \theta, \delta \phi) \ket{\Psi}=
    \cos\left(\frac{\theta + \delta \theta}{2}\right) \ket{0} +
    e^{i(\phi + \delta \phi)} 
    \sin\left(\frac{\theta + \delta \theta}{2}\right) \ket{1}.
\end{equation} 

Quantum errors can be digitazied using the Pauli matricies/operator. 
To show this we express the rot. op. $U$ using the Pauli set/\textcolor{red}{basis?} 
$\{\mathds{1},{X},{Z},{XZ}\}$
\footnote{We used that $XZ=Yc$, where $c$ is just a phase factor.}

\begin{equation}
    U(\delta \theta, \delta \phi)\ket{\Psi} = 
    \alpha_1 \mathds{1} \ket{\Psi} +
    \alpha_X X \ket{\Psi}+
    \alpha_Z Z \ket{\Psi}+
    \alpha_{XZ} XZ \ket{\Psi}
\end{equation}

Therefore any coherent rot.\footnote{This could also be generalized for arb. quantum processes} can be decomposed into a sum from the Pauli set. 
Resulting from this QEC codes with the ability to correct errors described by the $X$- and $Z$-Pauli matricies will be able to correct any (coherent) error!
This is the digitasition of errors for quantum computing. \cite{QECintro}


\subsection{Quantum error types}
There are only two fundamental error types, that need to be accounted for \cite{QECintro}

\begin{enumerate}
    \item Pauli $X$-type errors $=$ quantum bit-flips \\
    $\rightarrow$ maps: $X\ket{0} = \ket{1}; X \ket{\Psi}= \alpha X \ket{0} + \beta X \ket{1} = \alpha  \ket{1} + \beta \ket{0}   $
    \item Pauli $Z$-type errors $=$ phase-flips (no classical analogone)\\
    $\rightarrow$ maps:  $Z \ket{\Psi}= \alpha Z \ket{0} + \beta Z \ket{1} = \alpha  \ket{0} - \beta \ket{1}   $
\end{enumerate}
\textcolor{red}{What about erasure errors?}


\subsubsection{Erasure Errors}
Erasure errors are errors where certain, known qubits are lost or are known to have an error and are therfore considerd lost. 
For codes with distance $d$, erasure errors on a subset up to size $d-1$ can be recovered. \cite{QECmemory}


\subsection{Challenges of QEC}
Taken from \cite{QECintro}


\subsubsection{1. No cloning theorem}
It is not possible to construct a unitary operator $U_{clone}$ which performs the operation
\begin{equation}
    U_{clone}(\ket{\Psi} \otimes \ket{0}) \rightarrow \ket{\Psi} \otimes\ket{\Psi}
\end{equation}


\subsubsection{2. Both bit- and phase-flips}
QEC codes must be designed to detect both kinds ($X,Z$) of errors simultaneously!


\subsubsection{3. Wavefct. collpase}
We can not perform arbitrary measurments on the qubits. 
Some measurments will lead to wavefct collapse and erase encoded information.
\textcolor{red}{Better describe when the wavefct actually collapses}

$\rightarrow$ stabilizer measurments


\section{Active QEC}
By the active gathering of error information, entropy is effectively removed from the computation and dumped into the ancilla degrees of freedom, which are supplied in known states to collect the error information. \cite{QECmemory}


\subsection{QEC Code/Encoding}
The QEC code describes how the to represent the quantum information in the state space of many physical/elementary qubits. \cite{QECmemory}
\textcolor{red}{Is the QEC code only the encoding or also contains the chosen decoding ?}


\subsubsection{[[n,k,d]]-Notation}\label{sssec:nkd_notation}
Taken from \cite{QECintro}.
\begin{itemize}
    \item n: total number of physical qubits per codeword (also known as block size of the code \cite{QECmemory})
    \item k: number of encoded qubits (length of the logical qubit)
    \item d: code distance
\end{itemize}


\subsubsection{Code Concatenation}
Code concatenation is the procedure in which we take the elementary qubits of the code words of a code $C$ and replace them by encoded qubits of a new code $C'$. \cite{QECmemory}
\textcolor{red}{Should I add an example ?!}


\subsubsection{Example of Encoding with Spaces}
Taken from \cite{QECintro}: 
For example if we start with one qubit, we start with 
\begin{equation}
    \ket{\Psi} \in \mathcal{H}_2 = \text{span}\{\ket{0},\ket{1} \}.
\end{equation}
After the encoding (by adding another qubit) we get a 4-dim Hilbert space 
\begin{equation}
    \ket{\Psi} \in \mathcal{H}_4 = \text{span}\{\ket{00},\ket{01},\ket{10},\ket{11} \}.
\end{equation}
This higher dimensional space can be used to redundantly encode the information.
The logical qubit is defined within a 2-dim subspace, which is called the \textit{codespace} $\mathcal{L}$
\begin{equation}
    \ket{\Psi}_L \in \mathcal{L} = \text{span}\{\ket{00},\ket{11} \} \subset \mathcal{H}_4.
\end{equation}
Applying an error (e.g. bit-flip $X$) roatates the state in the \textit{error subspace} $\mathcal{F}$
\begin{equation}
    X_i \ket{\Psi}_L \in \mathcal{F} = \text{span}\{\ket{01},\ket{10} \} \subset \mathcal{H}_4.
\end{equation} 


\subsection{Stabilizer codes}\label{sec:basic.qc.stabilizer}
Stabilizer codes are a straightforward quantum generalization of classical binary \hyperref[sec:basic.math.linear_codes]{linear codes}. \cite{QECmemory}

The main idea behind stabilizer codes is, to encode $k$ logical qubits into $n$ physical qubits.
In this process we generate a subspace called the codespace $\mathcal{L} \subseteq (\mathbb{C}^2)^{\otimes n}$,
\textcolor{red}{It there the possiblity, that the codespace spans the complete space ?! no right?!} 
which is spanned by the states $\ket{\Psi}$ that are invariant under the action of a stabilizer group $\mathcal{S}$. \cite{QECmemory}
\begin{equation}
    \mathcal{L} = \{ \ket{\Psi} \in (\mathbb{C}^2)^{\otimes n}: S\ket{\Psi}=\ket{\Psi}  \forall S \in \mathcal{S}\}
\end{equation}

The advantage of this stabilizer formalism is that instead of specifying the code space by a basis of $2^n$-dimensional vectors we specify the codespace by the generators of the stabilizer group, which fix/stabilize these vectors. 
If there are $m=n-k$ linear independet generators (partiy checks/stabilizers) then the codespace $\mathcal{L}$ is $2^k$-dimensional (encodes $k$-qubits).
This description only requires us to specify only $n$ linearly independet partiy checks/stabilizers. \cite{QECmemory}


\subsubsection{Stabilizer Group}
The stabilizer group $\mathcal{S}$ is an Abelian subgroup of the Pauli group $\mathcal{P}_n$, with $-\mathds{1} \notin \mathcal{S}$.
For any stabilizer group $\mathcal{S}$ one can always find a set of generators
\begin{equation}
    \mathcal{S} = \langle S_1, ..., S_m \rangle
\end{equation}
such that $S_i\in \mathcal{P}_n$ are Hermitian Pauli operators. \textcolor{red}{are there non Hermitian Pauli operator?!} 
These generators specify our codespace! \cite{QECmemory}


\subsubsection{Centralizer of $\mathcal{S}$ in $\mathcal{P}_n$}
The set of operators in $\mathcal{P}_n$ which commutes with (all elements of) $\mathcal{S}$ is called the \textit{centralizer} of $\mathcal{S}$ in $\mathcal{P}_n$, defined as 
\begin{equation}
    \mathcal{C}(S) = \{ P \in \mathcal{P}_n | \forall S \in \mathcal{S}, PS = SP\}.
\end{equation}
We thus have $\mathcal{C}(\mathcal{S}) = \langle \mathcal{S}, \bar{X}_1, \bar{Z}_1, ..., \bar{X}_k, \bar{Z}_k\rangle$, 
therefore the logical operators of the codes are elements of 
\begin{equation}
    \bar{P} \in \mathcal{C}(\mathcal{S})\setminus \mathcal{S}.
\end{equation}
Based on this we can redefine the distance as
\begin{equation}
    d = \min_{P \in \mathcal{C}(\mathcal{S})\setminus\mathcal{S}} |P|
\end{equation}
i.e. the minimum weight of any logical operator.
completly stolen from \cite{QECmemory}.


\subsubsection{Codespace and Error Subspace}\label{sec:codespace_error_subspace}
\textcolor{red}{Are codespace and error subspace unique to stabilizer codes?}
While encoding, with an \hyperref[sssec:nkd_notation]{$[[n,k,d]]$ code}, we increase the size of the Hilbert space by adding $m=n-k$ redundancy qubits $\ket{0}_R$
to create a logical qubit $\ket{\Psi}_L$. 
Afterwards the data previously stroed solely in $\ket{\Psi}_D$ is distributed across the expanded Hilbert space.
This Hilbert space can then be split up into two subspaces. 
The \textit{codespace} $\mathcal{L}$ is the subspace on which the logical qubit is defined. \cite{QECintro}
This subspace is spanned by the code words, which are the 'long' version of the logical qubits/states.

The \textit{error subspace} $\mathcal{F}$ is the subspace, in which the logical qubit rotates to, when applying an error operator. 
The two subspaces ($\mathcal{F} , \mathcal{L}$) are mutual orthogonal. 
Therefore we can distinguish which subspace is occupid via projective measurments, 
without compromising the encoded quantum information!  \cite{QECintro}

$\rightarrow$ projective measurments = stabilizer measurments


\subsubsection{Stabilizer (Operator)}
A \textit{stabilizer} 
$S$ is a 
\hyperref[sec:basic.math.projection_operator]{projection operator} 
hat maps the states to the $\pm 1$ eigenspaces. 
The stabilizer of a $[[n,k,d]]$ code must satisfy
\begin{enumerate}
    \item must be a Pauli-group element. $S_i \in \mathcal{P}_n$ 
    \item must \textit{stabilize}\footnote{Leaves the logical state unchanged} all logical states $\ket{\Psi}_L$ of the code \\
    $\implies S_i \ket{\Psi}_L = (+1) \ket{\Psi}_L \forall \ket{\Psi}_L \in \mathcal{L} $ 
    \item all stabilizer must commute\footnote{
It is necessary that the stabilizer commute, so that they can be measured simultaneously/independent from each other. 
    } with one another $[S_i,S_j]=0 \ \forall (i,j)$
\end{enumerate}
Therefore the stabilizers of an $[[n,k,d]]$ code form an \textit{Abelian subgroup} $\mathcal{S}$ of the Pauli group. \cite{QECintro}
\begin{equation}
    \mathcal{S} = \{ S_i \in \mathcal{G}_n | S_i \ket{\Psi}_L = (+1) \ket{\Psi}_L \forall \ket{\Psi}_L\in \mathcal{C} \land [S_i,S_j]=0 \ \forall(i,j)\}
\end{equation}
Importantly the product of two stabilizers is also a stabilizer $S_i \cdot S_j \in \mathcal{S}$, due to
\begin{equation}
    S_i \cdot S_j  \ket{\Psi}_L = S_i (+1) \ket{\Psi}_L = (+1) \ket{\Psi}_L.
\end{equation}
Therefore we need to make sure that the set of $m=n-k$ stabilizers used in the \hyperref[sec:basic.qc.syndrome_extraction_process]{syndrome extraction process}
form a \hyperref[sec:basic.math.minimal_set]{minimal set}. 
\begin{equation}
    \mathcal{S}= \langle G_1, G_2, ..., G_m\rangle
\end{equation}

The important property of the stabilizer is, that they leave the logical qubits (states) unchanged ($+1$ eigenspace) 
and project (some) elements of the error subspace to the -1 eigenspace.
\footnote{
    Each stabilizer might only project some states from the error subspace on the $-1$ eigenspace. 
    But the set \textcolor{red}{SHOULD?!} project all elements from the error subspace to the $-1$ eigenspace. 
} \cite{QECintro}


\subsection{Logical Operators of Stabilizer Codes}
A $[[n,k,d]]$ code has $2k$ logical Pauli operators, which are nonunique as we can mulitply them trivially with the stabilizer and obtain equivalent operators. \cite{QECintro},\cite{QECmemory} 
Each logical qubit $i$ has a logical Pauli-$X$ op. $\bar{X}_i$ and a logical-$Z$ op. $\bar{Z}_i$. 
They allow the logical state to be modified without having to decode and reencode. \cite{QECintro}

Each pair $\bar{X}_i$, $\bar{Z}_i$ satisfies:
\begin{enumerate}
    \item they commute with all the code stabilizers in $\mathcal{S}$ 
    \item they anti-commute with one another, so that $\{ \bar{X}_i, \bar{Z_i}\}=0$ \textcolor{red}{\cite{QECmemory} does not demand this condition in the formalism part, only 1. and 3.?! is this enough?!}
    \item they should not be generated by the partiy checks temselves \cite{QECmemory}
\end{enumerate}
They therefore realize the algebra of the Pauli operators acting on the $k$-qubits. \cite{QECmemory}


\subsubsection{Example of Stabilizer Measurments}
Taken from \cite{QECintro}.
Errors can be deteced by performing $n-k=m$ stabilizer measurments $S_i$.
\textcolor{red}{Add the commutation condition with error operators}

Some examples for a stabilizer (here $Z_1 Z_2$) measurments for the previously shown encoding on the codespace
\begin{equation}
    Z_1 Z_2 \ket{\Psi}_L = Z_1 Z_2 (\alpha \ket{00}+ \beta \ket{11}) = +1 \ket{\Psi}_L
\end{equation}
and on the error subspace
\begin{equation}
    Z_1 Z_2 X_1\ket{\Psi}_L = Z_1 Z_2 (\alpha \ket{10}+ \beta \ket{01}) = -1 \ket{\Psi}_L.
\end{equation}
A stabilizer measurments projects the all elements of the codespace onto the $+1$ eigenspace 
and projects some (the set in total all) elements of error space onto the $-1$ eigenspace. 
The stabilizers therefore should anticommute with the errors! 

The information encoded in the logical qubit ($\alpha/\beta$ coef.) is undisturbed!

To form a \hyperref[sec:basic.math.minimal_set]{minimal set} we need to choose
\begin{equation}
    \mathcal{S} = \langle Z_1 Z_2, Z_2 Z_3 \rangle.
\end{equation}
An set of stabilizers for the three-qubit code that does not form a minimal set is
\begin{equation}
    \mathcal{S}' = \{ Z_1 Z_2, Z_2 Z_3, Z_1 Z_3\}
\end{equation}
as we can use the first two operator to obtain the last one. 


\subsection{Decoding}


\subsubsection{Syndrome Extraction Process}\label{sec:basic.qc.syndrome_extraction_process}
\begin{figure}[h]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{circuit_syndrome_extraction.png}
    \end{center}
    \caption{
        Circuit illustrating the structur of an $[[n,k,d]]$ stabilizer code. 
        A quantum data register $\ket{\Psi}_D$ is entangled with redundancy qubits $\ket{0}_R$ via an encoding operation to create a logical qubit $\ket{\Psi}_L$.
        After encoding, a sequence of $m = n - k$ stabilizer checks $S_i$ are performed on the register, and each result copied to an ancilla qubit $A_i$.         
        The subsequent measurement of the ancilla qubits provides an $m$-bit syndrome.
        Stolen from \cite{QECintro}.
    }
    \label{fig:basic.qc.syndrome_extraction.circuit}
\end{figure}
Errors can be detected using the $m=n-k$ \hyperref[sec:basic.qc.stabilizer]{stabilizers} $S_i$, which extract $m$-bit syndrome $s$ using the $m$ ancilla qubits $\ket{0}_{A_i}$.
This syndrome $s$ is the vector corresponding to the eigenvalues of the generators of $\mathcal{S}$.
This process is shown in figure \ref{fig:basic.qc.syndrome_extraction.circuit}. \cite{QECintro}

The corresponding equation to the circuit
\begin{equation}
    E \ket{\Psi}_L \ket{0}_{A_i} \rightarrow \frac{1}{2} (\mathds{1}^{\otimes n} + S_i) E \ket{\Psi}_L \ket{0}_{A_i} +  \frac{1}{2} (\mathds{1}^{\otimes n} - S_i) E   \ket{\Psi}_L \ket{1}_{A_i} 
\end{equation}
shows that the ancilla qubit $A_i$ returns '$0$' if the stabilizer $S_i$ and the error $E$ commute,
and returns '$1$' if they anticommute! 

The results of the $m$-stabilizer measurments are combined to give an $m$-bit syndrome.
The syndrome allows to deduce the best recovery operation to restore the logical state.


\subsubsection{Decoding the Syndrome}
\begin{figure}[h]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{circuit_active_error_rec.png}
    \end{center}
    \caption{
    Schematic of an active error correcting circuit with error process $E$, set of stabilizers $\mathcal{S}$, m-bit syndrome $S$ and recovery operation $R$.
    The decoder determines the best recovery operation $\mathcal{R}$ to return to the logical state, based on the syndrome $S$.
    Stolen from \cite{QECintro}.
    }
    \label{fig:basic.qc.qec_circuit}
\end{figure}
The relation $d = 2t+1$ tells us that if the distance $d\ge 3$ we can correct $t$ errors.
Therefore we get propper error correcting codes, where we apply active recovery operations based on the detected syndrome.
The general circuit schematic is shown in figure \ref{fig:basic.qc.qec_circuit}. \cite{QECintro}

We use the $m$-bit syndrome $S$ to find a recovery operation. 
This process is called decoding: 
decoding is the process in which we determine the best unitary operation $\mathcal{R}$ to return the state to the codespace based on the syndrome. \cite{QECintro}

The decoding step is a success if 
\begin{equation}
    \mathcal{R}E \ket{\Psi}_L = +1 \ket{\Psi}_L.
\end{equation}
This is trivially fullfiled for $\mathcal{R}E=\mathds{1}$ ($\mathcal{R}=E^\dagger$). 
This is also fullfiled for $\mathcal{R}E=S_i \in \mathcal{S}$.
Therefore there is no unique solution for $\mathcal{R}$ and we can design \textit{degenerate} quantum codes,
where mulitple error map to/are recovered by the same syndrome. \cite{QECintro}

The decoding fails if the recovery operation maps the code state to another logical state
\begin{equation}
    \mathcal{R}E \ket{\Psi}_L = L\ket{\Psi}_L.
\end{equation}
In this case the state is returned to the codespace, 
but the recovery operation a change in the encoded information! \cite{QECintro}

\textcolor{red}{
    According to \cite{QECmemory} all Erros that follow $E=E'P,\ P \in \mathcal{C}(\mathcal{S})$ share the same syndrome.
}



\subsubsection{Efficient Decoding Algorithms}
The possible syndrome scales with the code size as $2^m = 2^{n-k}$.
For example the surface code with $d=5$ ($[[41,1,5]]$) has $2^{40}\approx 10^{12}$ possible syndromes. 
Therefore lookup tables become inefficent! \cite{QECintro}

Large scale codes use \textit{approximate interference techniques}.
They determine the recovery operation which is \textit{most likely} to restores the encoded information to the codespace.
These methods allow the recovery operation to be choosen in real-time! \cite{QECintro}

The frequency with which the decoder fails is called the logical error rate $p_L$. 
And because the decoder introduces another point of failure for the QEC code, the choice of decoder can heavly influence the logical error rate of a QEC code.  \cite{QECintro}


\subsubsection{Equivalence Class of Errors}
Multiple errors can be restored by the same recovery operation.
These errors $E$ are related by the projection operators and form an equivalence class of erros $[E]$\footnote{
    $[E]$ is a coset of the gorup $\mathcal{S}$ in $\mathcal{P}_n$. 
} consisting of
\begin{equation}
    E' = ES, \  S \in \mathcal{S}.
\end{equation}

We can associate a total error probability, based on some error model, with such a class 
\begin{equation}
    \text{Prob}([E]) = \sum_{S\in S} \text{Prob}(ES).
\end{equation}

There is a discrete number of classes $[E\bar{P}]$, where $\bar{P}\in \mathcal{C}(\mathcal{S}) \setminus \mathcal{S}$ are logical operator. \cite{QECmemory}



\subsubsection{Maximum-Likelihood Decoding}
\textcolor{red}{The error is unknown to the maximum likelihood decoder, so how does he choose the correct equivalence class?}

\textcolor{red}{How does maximum likelihood decoder uses the syndrome.}

Given syndrome $s$ and error $E$, the maximum-likelihood decoder (MLD) capmare the probabilities 
\begin{equation}
    \text{Prob}([E\bar{P}])\ \forall \bar{P}.
\end{equation}
It then chooses the recovery operation which belongs to the equivalence class with the maximal likelihood $\max(\text{Prob}([E\bar{P}]))$.
This procedure is succefull if 
\begin{equation}
     \text{Prob}([E])>\text{Prob}([E\bar{P}])\ \forall \bar{P}
\end{equation}
because then the correct equivalence class has the highest probability. \cite{QECmemory}

To note how efficient this is, $\text{Prob}([E\bar{P}])$ is a sum over the number of elements in $\mathcal{S}$, which is itself exponential in $n$. \cite{QECmemory}


\subsection{Code Threshold}
The \textit{threshold theorem} for stabilizer codes states:
Increasing the distance of a code results in a reduction of the logical error rate $p_L$ 
if the physical error rate $p$ of individuals quibts is below a threshold $p<p_{th}$.
Therefore we have a condition for when codes can be used to supress the logical errors and where the process of QEC codes becomes self defeating. \cite{QECintro}

Upper bounds for $p_{th}$ for a given code under a given noise model can be obtained using methods from statistical meachanics.
More realistic threshold can be numerically estimated by simulating code cycles and decoding using efficient interference algorithms. \cite{QECintro}


\subsection{Fault tolerance}
A QEC code is said to be \textit{fault tolerant} if it can account for errors (of size up to the code distance) that occur at any location in the circuit.
We previously assumed that the syndrom extraction and encoding operates without error (as seen in figure \ref{fig:basic.qc.qec_circuit}).
Converting a code to be fault tolerant may lead to addition qubits needed, the reptations of syndrome extraction and a higher code threshold. \cite{QECintro}


\subsection{Encoded computation}
A \textit{universal quantum computer} is a device that can perform any unitary operation $U$ that evolves a quibt register from one state to another $U\ket{\Psi} = \ket{\Psi}'$.
Any such operation $U$ can be efficetly compiled from a finite set of elementary gate, so called \textit{universal gate set}. \cite{QECintro}

It possible to fault tolerantly implement a subset of the gates of a universal gat set without having to intoduce additional qubits. 
This is achvied by a definig logical operators with a property knows as \textit{transversality}, that gurantees errors will not spread uncontrollably through the circuit.
A no-go theorem exists that prohibts the implementation of a full universal gate set in this way. 
Therefore alternative techniques are required, but they typically impose high cost of additional qubits. \cite{QECintro}


\subsection{Surface Codes}
\textcolor{red}{Here I need more subtential infromation!}
\begin{figure}[h]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{surface_code_small.png}
    \end{center}
    \label{fig:basic.qc.surface_code_small}
\end{figure}
\begin{figure}[h]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{surface_code_big.png}
    \end{center}
    \label{fig:basic.qc.surface_code_big}
\end{figure}
General challenge in creating QEC codes is finding set of commuting stabilizers, 
which enable error detection whitout disturbing the contained information.

Surface codes belong to the broader family of \textit{topological codes}.
There general design principal is, that the code is constructed by connecting repeated elements together. 
This modular approach ensures scalibility whilst keeping commutativity.
A more practical advantage is that surface codes require only nearest-neighbour interaction. \cite{QECintro}

An example of a surface code can be found in figure \ref{fig:basic.qc.surface_code_small}.
And a scaled up version is visible in \ref{fig:basic.qc.surface_code_big}. \cite{QECintro}

The logical operators can be found on the edge of the lattice. 
The Pauli-$X$ logical operator can be defined as the chain of Pauli-$X$ operator along the boundary along which the $Z$-stabilizers (shown in blue) are applied.
The Pauli-$Z$ logical operator can be defined along the adjacend boundary! \cite{QECintro}


\subsubsection{Scaling of Surface Codes}
The distance of a surface code can be increased by scaling the size of the lattice.
In general the distance $d=\lambda$, will encode a \textit{single} logical qubit and have the code parameters \cite{QECintro}
\begin{equation}
    [[n = \lambda^2 + (\lambda-1)^2, k=1 ]]
\end{equation}


